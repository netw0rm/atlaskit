/*  Original source: https://forums.adobe.com/thread/1471138  Modified: lbatchelor, 27 June 2016    This script assumes you have one and only one property selected. It will export a list of keyframes that are more inline with how CSS animations treat keyframes.  That is to say, an array of points and control points that make up the animation curve for a specified property. Example output  {    "keyframes": [{        "p": [0, 0 ], // at 0% of the animation, the value should be 0        "cp": [ 0.33333333, 0,0.4,1 ] // curve to get to next keyframe    },{        "p": [ 0.5, -210 ], // at 50% of the animation, value should be -210        "cp": [ 0.4, 0, 0.6, 1 ]    },{        "p": [ 0.76666666666667, -195 ], // at 76% of the way,  value is -195        "cp": [ 0.4, 0, 0.6, 1 ]    }, {        "p": [ 1, -200 ] // final value of the property is -200, no control point neccessary     }],    "info": {        "property": "Y Position", // The property this animation curve came from        "original values": [0, -200] // The original start and end values of the curve        "duration (ms)": 500, // The original duration of the animation        "frames": 30 // The number of frames in the animation    }  }*/(function getCubicbeziers(){    var curItem = app.project.activeItem;    var selectedProperties = app.project.activeItem.selectedProperties;    var duration = curItem.duration;    var frameRate = curItem.frameRate;    var numFrames = duration / curItem.frameDuration;    var keyframes = [];    if (selectedProperties.length !== 1) {        alert('Please select a property to export (no more than one)');        return;    }     var selectedProperty = selectedProperties[0];    if(selectedProperty.numKeys < 2) {        alert('Selected property does not have any keyframes');        return;    }    // Get the starting and ending value of the property so we can normalize the values    var startingValue = selectedProperty.keyValue(1);    var endingValue = selectedProperty.keyValue(selectedProperty.numKeys);    var deltaValue = endingValue - startingValue;    for(var i = 1; i < selectedProperty.numKeys; i++) { /* for each keyframe in current property (1 based) */            var t1 = selectedProperty.keyTime(i); /* t1, t1 are the x values of the keyframes we are interpolating between */            var t2 = selectedProperty.keyTime(i + 1);            var val1 = selectedProperty.keyValue(i); /* val1, val2 are the y values of the keyframes we are interpolating between */            var val2 = selectedProperty.keyValue(i + 1);            var delta_t = t2 - t1; /* calculate the change in x and y */            var delta = val2 - val1;            var avSpeed = Math.abs( val2 - val1 ) / (t2 - t1);            if (val1 < val2) {                x1 = selectedProperty.keyOutTemporalEase(i)[0].influence /100;                y1 = x1*selectedProperty.keyOutTemporalEase(i)[0].speed / avSpeed;                x2 = 1 - selectedProperty.keyInTemporalEase(i + 1)[0].influence /100;                y2 = 1 - (1 - x2) * (selectedProperty.keyInTemporalEase(i + 1)[0].speed / avSpeed);            } else if (val2 < val1) {                x1 = selectedProperty.keyOutTemporalEase(i)[0].influence /100;                y1 = (-x1) * selectedProperty.keyOutTemporalEase(i)[0].speed / avSpeed;                x2 = selectedProperty.keyInTemporalEase(i + 1)[0].influence /100;                y2 = 1 + x2 * (selectedProperty.keyInTemporalEase(i + 1)[0].speed / avSpeed);                x2 = 1 - x2;            } else {                x1 = selectedProperty.keyOutTemporalEase(i)[0].influence / 100;                y1 = (-x1) * selectedProperty.keyOutTemporalEase(i)[0].speed / ((selectedProperty.maxValue - selectedProperty.minValue) / (t2 - t1));                x2 = selectedProperty.keyInTemporalEase(i + 1)[0].influence / 100;                y2 = 1 + x2 * (selectedProperty.keyInTemporalEase(i + 1)[0].speed / ((selectedProperty.maxValue - selectedProperty.minValue) / (t2 - t1)));                x2 = 1 - x2;            }            /* push our calculated keyframe to the list */            keyframes.push({                'p': [t1*(frameRate / numFrames), (val1 - startingValue) / deltaValue ], // [%time through animation, %through the total change in animation]                'cp': [x1, y1, x2, y2]            });        }        /* push the final keyframe (no control points) */        keyframes.push({            p: [t2*(frameRate / numFrames), (val2 - startingValue) / deltaValue] // Should always be [1, 1], will serve as a sanity test        });        var output = {            keyframes: keyframes,            info: {                'property': selectedProperty.name,                'original values': [startingValue, endingValue],                'duration (ms)': duration*1000,                'frames': numFrames            }        }        /* Make arrays show on one line by joining them and returning as a string*/        var stringified = JSON.stringify(output, function arrayToOneLineString(key, value) {            if (key === 'p' || key === 'cp' || key === 'original values') {                return '['+value.join(', ') + ']';            }            return value;        }, 4);        stringified = stringified.replace(/"/g, '\'') /* replace double quotes with quotes */            .replace(/'(\[.+\])'/g, '$1'); /* remove the quotes around the arrays */        alert(selectedProperty.name+'\n'+stringified);})();