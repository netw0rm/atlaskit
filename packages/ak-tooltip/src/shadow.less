// These styles will be inserted into a style tag inside
// the shadow dom of each instance of the component
@import '~akutil-shared-styles/src/colors.less';
@import '~akutil-shared-styles/src/mixins/animations.less';

@grid: 4;
@fontSize: unit(3 * @grid, px);
@lineHeight: (4 * @grid) / unit(@fontSize);
@fontColor: white;
@maxWidth: unit(105 * @grid, px); // ~420px
@borderRadius: 3px;
@leftAndRightTextPadding: unit(2 * @grid, px);
@topAndBottomPadding: unit(@grid / 2, px);
@marginDistance: unit(2 * @grid, px);
@animationMovementDistance: (3 * @grid);
@animationDelay: 0.1s;
@animationTime: @animationDelay + 1s;

// Because of the shadow DOM boundries we can not style the host element the usual way
// To do this the ':host' pseudo-class should be used
// Also we should style the tag name with the same styles because of the browsers
// that do not support shadow DOM
.host-styles() {
  // we remove pointer events to prevent the tooltip from getting in the way of hovering
  pointer-events: none;
  display: inline-block;

  &:not([defined]) {
    display: none;
  }
}

// we define a class here in order to re-use it in the storybook
// (because in storybook the component name is randomly generated)
.ak-tooltip,
ak-tooltip {
  .host-styles();
}

:host {
  .host-styles();
}

// Putting these styles in host.less with :not([visible]) causes a slight flash when moving the
// mouse in the direction of the animation. Putting it here makes it work perfectly.
.hidden {
  top: -100vh;
  left: -100vw;
  position: absolute;
}

.tooltip {
  background-color: @ak-color-N900;
  border-radius: @borderRadius;
  box-sizing: border-box;
  color: @fontColor;
  font-size: @fontSize;
  line-height: @lineHeight;
  max-width: @maxWidth;
  margin: @marginDistance;
  padding: @topAndBottomPadding @leftAndRightTextPadding;
  pointer-events: none;
}

//************** Animations ***************//

// define the props to transform for each animation
@slideUp: 'transform', 'translateY(XXpx)', @animationMovementDistance, 0;
@slideDown: 'transform', 'translateY(XXpx)', -@animationMovementDistance, 0;
@slideLeft: 'transform', 'translateX(XXpx)', @animationMovementDistance, 0;
@slideRight: 'transform', 'translateX(XXpx)', -@animationMovementDistance, 0;
@fadeIn: 'opacity', 'XX', 0, 1;

// then create the keyframes for each
.createBoldAnimation(@slideUp @fadeIn, 'slide-up');
.createBoldAnimation(@slideDown @fadeIn, 'slide-down');
.createBoldAnimation(@slideLeft @fadeIn, 'slide-left');
.createBoldAnimation(@slideRight @fadeIn, 'slide-right');

// and create classes to apply them
.slideUpAnimation {
  animation: slide-up @animationTime @animationDelay backwards;
}
.slideDownAnimation {
  animation: slide-down @animationTime @animationDelay backwards;
}
.slideLeftAnimation {
  animation: slide-left @animationTime @animationDelay backwards;
}
.slideRightAnimation {
  animation: slide-right @animationTime @animationDelay backwards;
}
