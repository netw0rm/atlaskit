# Common test utilities for AtlasKit





[//]: # (EVERYTHING BELOW THIS COMMENT WAS GENERATED BY JSDOC AND NEEDS TO BE MOVED INTO A STORYBOOK)
[//]: # (DO NOT CHANGE THIS FILE HERE - CREATE THE STORYBOOK!)







## Functions

<dl>
<dt><a href="#afterMutations">afterMutations()</a></dt>
<dd><p>Runs a list of functions, pausing between each one to ensure the component
   has had time to re-render.
   Ensure that you pass <code>done</code> into the test and that you call it at the end
   as this will make your tests asyncronous.</p>
</dd>
<dt><a href="#default">default(define, definition, [target])</a> ⇒ <code>Promise.&lt;Component&gt;</code></dt>
<dd><p>Creates a temporary component from a SkateJS module definition</p>
</dd>
<dt><a href="#getRootNode">getRootNode(component)</a> ⇒ <code>Node</code></dt>
<dd><p>Returns the root node of the passed component</p>
</dd>
<dt><a href="#getShadowRoot">getShadowRoot(component)</a></dt>
<dd><p>A simple helper method to retrieve a shadowRoot from a component</p>
</dd>
<dt><a href="#hasClass">hasClass(component, [...classes])</a></dt>
<dd><p>A simple helper method to check whether a node has a set of classNames on it.
 Will return true, only if a component is provided and it has all the classNames applied to it.</p>
</dd>
<dt><a href="#locateWebComponent">locateWebComponent(componentNamePrefix, [parentElement])</a> ⇒ <code>Array.&lt;Node&gt;</code></dt>
<dd><p>locates a web component by its prefix.</p>
<p>Note: this is also used in protractor as a custom locator, so the signature of the method has
to follow the protractor spec</p>
</dd>
<dt><a href="#tearDownComponent">tearDownComponent(component, [target])</a></dt>
<dd><p>Removes a component from the target node</p>
</dd>
<dt><a href="#keydown">keydown(key, options)</a></dt>
<dd><p>Simulate a user&#39;s keydown input</p>
</dd>
<dt><a href="#keyup">keyup(key, options)</a></dt>
<dd><p>Simulate a user&#39;s keyup input</p>
</dd>
<dt><a href="#keypress">keypress(key, options)</a></dt>
<dd><p>Simulate a user&#39;s keypress input</p>
</dd>
<dt><a href="#checkInvisibility">checkInvisibility(elem)</a></dt>
<dd><p>returns true if and only if <code>elem</code> is invisible</p>
</dd>
<dt><a href="#checkVisibility">checkVisibility(elem)</a></dt>
<dd><p>returns true if and only if <code>elem</code> is visible</p>
</dd>
<dt><a href="#waitUntil">waitUntil(fn, timeout, step)</a></dt>
<dd><p>waitUntil is a testHelper to wait an arbitrary amount of time until a
condition is met.
It takes in a function (the condition of when to keep running) and returns a promise.
This is useful when you want to make changes to a component and then ensure that it has been
rendered before performing any tests.
Within tests this is safe as they will automatically fail after 2000ms of not responding.</p>
</dd>
</dl>

<a name="afterMutations"></a>

## afterMutations()
Runs a list of functions, pausing between each one to ensure the component
   has had time to re-render.
   Ensure that you pass `done` into the test and that you call it at the end
   as this will make your tests asyncronous.

**Kind**: global function

| Param | Type | Description |
| --- | --- | --- |
| fn... | <code>function</code> | A list of functions to run in order.                    Each function is passed the return value of the last function                    (except for the last) |

**JS Example**
```js
it('should respond to prop changes', (done) => {
   afterMutations(
     () => expect(component).to.be.in.some.state,
     () => props(component, {propName, propValue}),
     () => expect(component).to.be.in.another.state,
     () -> props(component, {propName, anotherValue}),
     () => expect(component).to.be.in.another.another.state,
     done
   );
 });
```
<a name="default"></a>

## default(define, definition, [target]) ⇒ <code>Promise.&lt;Component&gt;</code>
Creates a temporary component from a SkateJS module definition

**Kind**: global function
**Returns**: <code>Promise.&lt;Component&gt;</code> - A promise resolving to a ready-to-use instance of the created
temporary SkateJS WebComponent.

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| define | <code>function</code> |  | The SkateJS define function. This needs to be passed in so that vdom doesn't get confused between your components skate and the skate from akutil-common-test. |
| definition | <code>object</code> &#124; <code>Component</code> |  | The SkateJS definition to base the temporary component upon |
| [target] | <code>Node</code> | <code>document.body</code> | The target element to which the component should be appended |

<a name="getRootNode"></a>

## getRootNode(component) ⇒ <code>Node</code>
Returns the root node of the passed component

**Kind**: global function
**Returns**: <code>Node</code> - The root node of the passed component

| Param | Type | Description |
| --- | --- | --- |
| component | <code>Component</code> | The component to get the root node for |

<a name="getShadowRoot"></a>

## getShadowRoot(component)
A simple helper method to retrieve a shadowRoot from a component

**Kind**: global function

| Param | Type | Description |
| --- | --- | --- |
| component | <code>Node</code> | A node to pull the shadowRoot from. |

**JS Example**
```js
const elem = document.querySelector('.fixture').firstChild;
 const sr = getShadowRoot(elem);
```
<a name="hasClass"></a>

## hasClass(component, [...classes])
A simple helper method to check whether a node has a set of classNames on it.
 Will return true, only if a component is provided and it has all the classNames applied to it.

**Kind**: global function

| Param | Type | Description |
| --- | --- | --- |
| component | <code>Node</code> | A node to check for classNames. |
| [...classes] | <code>String</code> | A list of classNames to check for the existance of |

**JS Example**
```js
const elem = document.querySelector('.fixture').firstChild;
 const elemIsHidden = hasClass(elem, 'hidden');
 const elemIsSelectedAndHidden = hasClass(elem, 'hidden', 'selected');
```
<a name="locateWebComponent"></a>

## locateWebComponent(componentNamePrefix, [parentElement]) ⇒ <code>Array.&lt;Node&gt;</code>
locates a web component by its prefix.

Note: this is also used in protractor as a custom locator, so the signature of the method has
to follow the protractor spec

**Kind**: global function
**Returns**: <code>Array.&lt;Node&gt;</code> - An array of DOM elements

| Param | Type | Description |
| --- | --- | --- |
| componentNamePrefix | <code>String</code> | The name of the web component (will be used as a prefix) |
| [parentElement] | <code>Node</code> | The parent element to search in. Will use document if omitted. |

<a name="tearDownComponent"></a>

## tearDownComponent(component, [target])
Removes a component from the target node

**Kind**: global function

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| component | <code>object</code> |  | The component that needs to be removed |
| [target] | <code>object</code> | <code>document.body</code> | The target element from which the component needs to be removed |

<a name="keydown"></a>

## keydown(key, options)
Simulate a user's keydown input

**Kind**: global function

| Param | Type | Description |
| --- | --- | --- |
| key |  | – the key to press, will be passed to keycode |
| options | <code>Object</code> | – options for the event. |
| options.target |  | – a DOM element to trigger the event on. Default:triggered on the document. |
| options.eventProperties | <code>Object</code> | – properties to assign to the event (see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent) |

<a name="keyup"></a>

## keyup(key, options)
Simulate a user's keyup input

**Kind**: global function

| Param | Type | Description |
| --- | --- | --- |
| key |  | – the key to press, will be passed to keycode |
| options | <code>Object</code> | – options for the event. |
| options.target |  | – a DOM element to trigger the event on. Default:triggered on the document. |
| options.eventProperties | <code>Object</code> | – properties to assign to the event (see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent) |

<a name="keypress"></a>

## keypress(key, options)
Simulate a user's keypress input

**Kind**: global function

| Param | Type | Description |
| --- | --- | --- |
| key |  | – the key to press, will be passed to keycode |
| options | <code>Object</code> | – options for the event. |
| options.target |  | – a DOM element to trigger the event on. Default:triggered on the document. |
| options.eventProperties | <code>Object</code> | – properties to assign to the event (see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent) |

<a name="checkInvisibility"></a>

## checkInvisibility(elem)
returns true if and only if `elem` is invisible

**Kind**: global function

| Param | Description |
| --- | --- |
| elem | – the element to check |

<a name="checkVisibility"></a>

## checkVisibility(elem)
returns true if and only if `elem` is visible

**Kind**: global function

| Param | Description |
| --- | --- |
| elem | – the element to check |

<a name="waitUntil"></a>

## waitUntil(fn, timeout, step)
waitUntil is a testHelper to wait an arbitrary amount of time until a
condition is met.
It takes in a function (the condition of when to keep running) and returns a promise.
This is useful when you want to make changes to a component and then ensure that it has been
rendered before performing any tests.
Within tests this is safe as they will automatically fail after 2000ms of not responding.

**Kind**: global function

| Param | Description |
| --- | --- |
| fn | function that must return true when it is time for the promise to continue |
| timeout | maximum amount of time waitUntil should wait before quiting (ms). |
| step | amount of time to wait between checks of the `fn` condition (ms). |

**JS Example**
```js
const elem = document.querySelector('.fixture').firstChild;
 // We put name our condition function so we can re-use it a couple of times
 const elemRenderedImgTag = () => (elem.shadowRoot.querySelector('img') !== null);

 // check that no image is rendered before we start
 expect(elemRenderedImgTag()).to.equal(false);

 // set a property to make the image be rendered
 elem.showImage = true;

 // now wait until we can see the image rendered
 waitUntil(elemRenderedImgTag).then(() => (expect(elemRenderedImgTag()).to.equal(true)));

 // alternatively, we might want to do more things in the .then call, even chain more waitUntils

 waitUntil(elemRenderedImgTag).then(() => {
   expect(elemRenderedImgTag()).to.equal(true);
   doSomeMoreStuff(elem);
   return waitUntil(someOtherConditionIsTrue());
 }).then(() => {
   // Now we can do more stuff in here!
    });

 // You can also set a maximum amount of time to wait (and how long to wait in between attempts)
 waitUntil(elemRenderedImgTag, 1000, 10).then(() =>
 (expect(elemRenderedImgTag()).to.equal(true)));
 // this will check if the img was rendered every 10ms for up to a total of ~1 second.
```